<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>美是美的创造者</title><link href="http://tonyho.github.io/" rel="alternate"></link><link href="http://tonyho.github.io/feeds/tonyho.atom.xml" rel="self"></link><id>http://tonyho.github.io/</id><updated>2014-01-10T00:00:00+08:00</updated><entry><title>Linux设备驱动开发基础之互斥与同步基础</title><link href="http://tonyho.github.io/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E5%9F%BA%E7%A1%80.html" rel="alternate"></link><updated>2014-01-10T00:00:00+08:00</updated><author><name>TonyHo</name></author><id>tag:tonyho.github.io,2014-01-10:Linux设备驱动开发基础之互斥与同步基础.html</id><summary type="html">&lt;h1&gt;Linux设备驱动开发基础之互斥与同步基础&lt;/h1&gt;
&lt;h2&gt;一些概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;竟态：多个执行路径对同一资源进行操作时可能引发的资源混乱行为（①）。执行路径为并发源。&lt;/li&gt;
&lt;li&gt;临界区：对共享资源的访问代码片段。临界区只能是在一个进程内部而无法跨进程，因为其不是一个对象，我们无法定义一个临界区对象来告知其他进程，而像Mutex和SpinLock都可以。参考&lt;a href="http://blogs.msdn.com/b/larryosterman/archive/2005/08/24/455741.aspx?Redirected=true"&gt;这篇文章&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;中断和抢占：一般都是在中断需要返回前会调用重新调度函数，如果没有禁止抢占，那么就会被高优先级的进程抢占。有的地方可以被中断但是进程必须不被抢占，那么只需要禁止抢占就行了。例如spin_lock是可以被中断的，但是不能被抢占,因为被其他进程抢占后会造成死锁。当然因为中断中也可能要去获得这个锁而造成死锁，这个就是spin_lock_irq的来由。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;原子操作与原子变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;原子操作：每一步都是不可分割的。&lt;/li&gt;
&lt;li&gt;原子变量：对此变量的操作（增加或者减小）是原子操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;单核处理器+抢占&lt;/code&gt; 与 &lt;code&gt;多核处理器&lt;/code&gt;在许多发面有类似的特性。&lt;/p&gt;
&lt;h2&gt;并发的来源&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;li&gt;调度器的可抢占性&lt;/li&gt;
&lt;li&gt;多核、多处理器的并发执行&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;中断&lt;/h4&gt;
&lt;p&gt;一般对于本地CPU（就是此刻运行这个代码的CPU或者CPU核），控制其中断使用的函数是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;local_irq_enable&lt;/li&gt;
&lt;li&gt;local_irq_disable&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;调度器的可抢占性&lt;/h4&gt;
&lt;p&gt;调度器的控制函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;preempt_disable&lt;/li&gt;
&lt;li&gt;preempt_enable&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;多核、多处理器的并发执行&lt;/h4&gt;
&lt;p&gt;以上是并发的来源，而下面的方法都是对并发的处理和控制，因此都是&lt;strong&gt;全局的&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;自旋锁=禁止抢占+原子设置V变量&lt;/h2&gt;
&lt;h4&gt;特征&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;对于spin_lock用得比较多的是对全局变量访问时的保护&lt;/li&gt;
&lt;li&gt;spin_lock是全局的&lt;/li&gt;
&lt;li&gt;普通的自旋锁(没有disable_IRQ)有可能会死锁&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;自旋锁和信号量的区别&lt;/h4&gt;
&lt;h6&gt;是否会引发睡眠&lt;/h6&gt;
&lt;p&gt;自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环
查看是否该自旋锁的保持者已经释放了锁，“自旋”就是“在原地打转”。而信号量则引起调
用者睡眠，它把进程从运行队列上拖出去，除非获得锁。&lt;/p&gt;
&lt;p&gt;spin_lock，禁止抢占，并且用一个变量来指明资源是否真正被使用。&lt;/p&gt;
&lt;h6&gt;是否会造成死锁&lt;/h6&gt;
&lt;p&gt;spin_lock因为没有禁止中断，所以有可能出现死锁&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在A进程用自旋锁锁住并使用资源B，处于临界区中，接着被中断，而中断中又去尝试使用资源B，这将造成死锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;spin_lock的组成和原理&lt;/h5&gt;
&lt;p&gt;spin 结构体中里面有个变量，这个变量在spin_lock中被原子改变。因此其他地方再去spin_lock的时候会发现这个变量已经改变，表明锁已经被使用了，此时将在这里自旋等待。&lt;/p&gt;
&lt;h5&gt;spin_lock_irq(Save)变体&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;spin_lock_irq&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;spin_lock_irq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Save&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;spin_lock&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;disableIRQ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而普通的spin_lock为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;spin_lock&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;原子设置&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;preempt_disable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个使得就解决了上面因为中断而造成的死锁的可能性。
2. spin_lock_bh&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;disable&lt;/span&gt; &lt;span class="n"&gt;softIRQ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;非阻塞版本&lt;/p&gt;
&lt;p&gt;spin_trylock：try&lt;/p&gt;
&lt;h5&gt;spin_lock_irq使用注意&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;任何拥有自旋锁的代码都必须是原子的，不能休眠：例如kmalloc中有GFP_KERNEL掩码时，将有可能造成休眠&lt;/li&gt;
&lt;li&gt;在中断中如果要使用自旋锁应该使用&lt;code&gt;spin_lock_irq&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;信号量&lt;/h2&gt;
&lt;h4&gt;特点&lt;/h4&gt;
&lt;p&gt;允许调用它的进程进入睡眠放入到wait_list中，见下面的结构体成员。&lt;/p&gt;
&lt;h4&gt;原理&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Please don&amp;#39;t access any members of this structure directly */&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;spinlock_t      lock;
unsigned int        count;
struct list_head    wait_list;
    };
1. lock：一个自旋锁用于对count变量的原子更改。
1. count：记录资源数目。
1. wait_list：将无法获取信号量的进程放入队列中。&lt;/p&gt;
&lt;h4&gt;操作&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;DOWN:&lt;/li&gt;
&lt;li&gt;count--&lt;/li&gt;
&lt;li&gt;UP:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;count++;唤醒在wait_list中的等待进程&lt;/p&gt;
&lt;h4&gt;UP/DOWN的变体&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;down：等待的进程无法被（Ctrl+D）中断,将阻塞在down中。&lt;/li&gt;
&lt;li&gt;down_interruptible：等待的进程可以被中断，需要检查返回值以确定究竟是什么原因导致的返回。&lt;/li&gt;
&lt;li&gt;down_trylock：如果无法获取信号量则直接返回而不是进入休眠。&lt;/li&gt;
&lt;li&gt;up函数只有一个。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;互斥锁&lt;/h2&gt;
&lt;h4&gt;构成&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;/&lt;em&gt; 1: unlocked, 0: locked, negative: locked, possible waiters &lt;/em&gt;/
atomic_t        count;
spinlock_t      wait_lock;
struct list_head    wait_list;
    #if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_SMP)
struct task_struct  &lt;em&gt;owner;
    #endif
    #ifdef CONFIG_DEBUG_MUTEXES
const char      &lt;/em&gt;name;
void            *magic;
    #endif
    #ifdef CONFIG_DEBUG_LOCK_ALLOC
struct lockdep_map  dep_map;
    #endif
    };
精简一下就是：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;struct mutex {
    /&lt;em&gt; 1: unlocked, 0: locked, negative: locked, possible waiters &lt;/em&gt;/
    atomic_t        count;
    spinlock_t      wait_lock;
    struct list_head    wait_list;
};
与上面的semophore相比，就是count的类型从&lt;code&gt;unsigned int&lt;/code&gt;编程了&lt;code&gt;atomic_t&lt;/code&gt;,且用1表示没有被锁，0表示锁了。而semophore里面的count则是用来表示可以获取资源的数目。互斥锁就是用来表示一个进程可以获取资源的。&lt;/p&gt;
&lt;h4&gt;操作&lt;/h4&gt;
&lt;p&gt;与semophore一致有UP和DOWN。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;免锁机制RCU：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;RCU&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;preempt_disable&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;每次写都分配一个新空间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;免锁的代价：规则约定&lt;/h4&gt;
&lt;p&gt;必须在临界区读。&lt;/p&gt;
&lt;h4&gt;RCU实现机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;写：先重新分配的一个地方，得到一个指针New，然后写进去，接着将这个new指针替换掉指向老数据的老指针Old。这样子完成了数据的刷新。当然指针的替换是原子操作的。最后还需要注册一个回调函数，使得所有对old指针的引用都完成后，用于释放以前分区的空间。&lt;/li&gt;
&lt;li&gt;释放旧空间：如果只有一个访问，那么读取者的临界区的出口其实就是这个回调函数调用的时机，因为读取者能且仅能在临界区引用指针，但是一个系统很可能有多个CPU运行多个线程去读取和引用old指针，所以当&lt;strong&gt;所有的CPU的发生过一次调度后&lt;/strong&gt;（就是绝对不可能在临界区，因为临界区关闭了调度），就可以认为是对老指针引用的完毕。&lt;/li&gt;
&lt;li&gt;读：构建一个临界区，&lt;strong&gt;并在且只在&lt;/strong&gt;临界区内使用指针访问数据。构建临界区的原因是防止在使用指针访问的时候数据被写。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;①来源于深入Linux设备驱动程序内核机制&lt;/p&gt;
&lt;p&gt;②&lt;a href="http://blogs.msdn.com/b/larryosterman/archive/2005/08/24/455741.aspx?Redirected=true"&gt;Why don't critical sections work cross process?&lt;/a&gt;&lt;/p&gt;</summary><category term="ES"></category><category term="LDD"></category></entry><entry><title>Linux驱动开发之内存管理基础</title><link href="http://tonyho.github.io/Linux%20MemoryManagement.html" rel="alternate"></link><updated>2013-12-30T00:00:00+08:00</updated><author><name>TonyHo</name></author><id>tag:tonyho.github.io,2013-12-30:Linux MemoryManagement.html</id><summary type="html">&lt;p&gt;内存管理主要分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;物理内存管理&lt;/li&gt;
&lt;li&gt;虚拟内存管理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;物理内存管理&lt;/h2&gt;
&lt;h3&gt;页&lt;/h3&gt;
&lt;p&gt;物理内存以页（&lt;code&gt;page frame&lt;/code&gt;）为单位，一般为4K，如果是4G的内存那么，将会有一个大小为&lt;code&gt;4G/4K=1M&lt;/code&gt;的数组&lt;code&gt;mem_map&lt;/code&gt;，每一项保存着每一页的地址。&lt;/p&gt;
&lt;h3&gt;Zone&lt;/h3&gt;
&lt;p&gt;Zone是一些连续物理页的合集，参看下面的图3-2。将物理页分成了3个Zone区：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ZONE_HIGHMEM：物理内存高于896M的区域&lt;/li&gt;
&lt;li&gt;ZONE_NORMAL：常规内存区域，如果DMA可以在此区域做内存访问，也可以使用这块区域&lt;/li&gt;
&lt;li&gt;ZONE_DMA：0~nM，不同的架构和不同的芯片都可能不一样&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为数组mem_map与物理页对应，因此mem_map也被默认分为了上面三个区域。&lt;/p&gt;
&lt;h3&gt;内存节点&lt;/h3&gt;
&lt;p&gt;分为两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UMA：只有一个内存节点，CPU访问内存的内存的任何地址的速度是一样的。&lt;/li&gt;
&lt;li&gt;NUMA：多&lt;code&gt;个&lt;/code&gt;处理器，每个处理器都有自己的本地内存，通过总线通讯。访问本地内存比访问其他节点的内存快。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;物理页面分配器：伙伴系统&lt;/h2&gt;
&lt;h3&gt;伙伴系统的特征与作用：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用物理页为单位&lt;/li&gt;
&lt;li&gt;记录哪些是空闲的物理页，那些是内核使用过的物理页&lt;/li&gt;
&lt;li&gt;可以让系统分配一个或者多个&lt;code&gt;连续的物理页&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;kernel启动后会映射&lt;code&gt;物理页面直接映射区&lt;/code&gt;，但是&lt;code&gt;ZONE_HIGHMEM&lt;/code&gt;区域并没有被映射到内核的虚拟地址上：&lt;/p&gt;
&lt;p&gt;&lt;img alt="物理内存等映射" src="./static/MemoryManagement/pics/mem_map.jpg" /&gt;&lt;/p&gt;
&lt;h3&gt;gfp_mask&lt;/h3&gt;
&lt;p&gt;要指定分配哪个ZONE的物理页，以及分配时的行为是由&lt;code&gt;gfp_mask&lt;/code&gt;（gfp：Get free page）掩码的不同组合成的flag来决定的。
对于分配到哪个区域的掩码定义有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#define __GFP_DMA   ((__force gfp_t)___GFP_DMA)&lt;/span&gt;
&lt;span class="c"&gt;#define __GFP_HIGHMEM   ((__force gfp_t)___GFP_HIGHMEM)&lt;/span&gt;
&lt;span class="c"&gt;#define __GFP_DMA32 ((__force gfp_t)___GFP_DMA32)&lt;/span&gt;
&lt;span class="c"&gt;#define __GFP_MOVABLE   ((__force gfp_t)___GFP_MOVABLE) &lt;/span&gt;
&lt;span class="c"&gt;#define GFP_ZONEMASK    (__GFP_DMA|__GFP_HIGHMEM|__GFP_DMA32|__GFP_MOVABLE)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果不指定，默认是分配在&lt;code&gt;ZONE_NORMAL&lt;/code&gt;区域。当然以&lt;code&gt;__&lt;/code&gt;开头指明这些宏是在头文件内部使用，kernel还定义了以这些为基础的宏，在驱动中应该使用这些进一步包装的宏：
1. __GFP_NORMAL：在ZONE_NORMAL区域分配，如果&lt;/p&gt;
&lt;p&gt;另外还有几个常用的mask：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#define GFP_ATOMIC  (__GFP_HIGH)&lt;/span&gt;
&lt;span class="c"&gt;#define GFP_KERNEL  (__GFP_WAIT | __GFP_IO | __GFP_FS)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;GFP_ATOMIC：没有&lt;code&gt;__GFP_WAIT&lt;/code&gt;表明&lt;code&gt;不允许中断且不需要被调度出去&lt;/code&gt;。在中断例程中常用。&lt;/li&gt;
&lt;li&gt;GFP_KERNEL：有可能会被中断和调度出去。驱动中最常用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;页面分配规则和优先级&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;不指定：默认使用&lt;code&gt;ZONE_HIGHMEM&lt;/code&gt;，如果不足那么到&lt;code&gt;ZONE_DMA&lt;/code&gt;分配空间。&lt;/li&gt;
&lt;li&gt;__GFP_HIGHMEM：先到&lt;code&gt;ZONE_HIGHMEM&lt;/code&gt;分配空间，若不足，则到&lt;code&gt;ZONE_NORMAL&lt;/code&gt;去分配页面，如果还是不够，那么就会到&lt;code&gt;ZONE_DMA&lt;/code&gt;中去分配。就是就是从上到下的找空间。&lt;/li&gt;
&lt;li&gt;__GFP_DMA：在&lt;code&gt;ZONE_DMA&lt;/code&gt;中分配页面，如果空间不足，那么失败返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;核心页面分配函数&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;alloc_pages&lt;/li&gt;
&lt;li&gt;__get_free_pages：无法在HIGHMEM分配页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两个函数最终都是调用&lt;code&gt;alloc_pages_node&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;alloc_pages与free_pages&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://hi.baidu.com/tonyhoaspire/item/7a952ec8cbd84c65f7c95d04"&gt;这里&lt;/a&gt;有一个使用此函数的例子。加载这个例子的模块有可能会出现问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Unknown&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="n"&gt;mem_map&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以查看在/proc/kallsys或者是System.map中是否有这个变量。&lt;/p&gt;
&lt;p&gt;这个例子里面也用到了&lt;code&gt;page_address&lt;/code&gt;来获得内核虚拟地址(&lt;code&gt;KVA&lt;/code&gt;)。
alloc_pages的原型如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;* @gfp_mask [in] 就是上面说的那些掩码组合flag&lt;/span&gt;
&lt;span class="cm"&gt;* @order [in] 需要分配空间的2的指数值&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;alloc_pages&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gfp_mask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; \
    &lt;span class="n"&gt;alloc_pages_node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numa_node_id&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;gfp_mask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例如：
     struct page *pages = alloc_pages(GFP_KERNEL,3);  //分配2^3=8个物理页  &lt;br /&gt;
&lt;code&gt;free_pages&lt;/code&gt;用来释放alloc_pages分配的页。&lt;/p&gt;
&lt;h4&gt;__get_free_pages&lt;/h4&gt;
&lt;p&gt;这个函数除了gfp_mask无法使用__GFP_HIGHTMEM外，与alloc_pages没有什么差别。
使用&lt;code&gt;__free_pages&lt;/code&gt;来释放用此函数分配的页。&lt;/p&gt;
&lt;h3&gt;get_zeroed_page和__get_dma_pages&lt;/h3&gt;
&lt;p&gt;一个是分配填充为0的页，一个是在ZONE_DMA分配页。&lt;/p&gt;
&lt;h2&gt;slab分配器：分配比一个页更小的空间&lt;/h2&gt;
&lt;p&gt;在字符设备驱动中，经常有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;cdev&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cdev_a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kmalloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;cdev&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;GFP_KERNEL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里一个cdev结构体比一个page的大小（4KB）小，使用的是kmalloc来分配。slab就是用来完成小空间分配需要的。&lt;/p&gt;
&lt;p&gt;kmem_cache包含多个slab，根据不同的order的放在一个队列上面。而每一个order下又根据使用情况分为三种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空闲&lt;/li&gt;
&lt;li&gt;部分空闲&lt;/li&gt;
&lt;li&gt;已满&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="物理内存等映射" src="./static/MemoryManagement/pics/slab.jpg" /&gt;&lt;/p&gt;
&lt;h3&gt;slab中的kmalloc和kzalloc&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;slab只能在低端内存区域分配空间，所以即使kmalloc的gfp_mask使用__GFP_HIGHMEM也无法分配到高端内存。&lt;/li&gt;
&lt;li&gt;kzalloc == kmalloc(size,__GFP_ZEROED|flag)&lt;/li&gt;
&lt;li&gt;获得的是连续的物理内存&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;虚拟内存管理&lt;/h2&gt;
&lt;h4&gt;vmalloc&lt;/h4&gt;
&lt;p&gt;获得连续的虚拟内存&lt;/p&gt;
&lt;h4&gt;ioremap&lt;/h4&gt;
&lt;p&gt;用来将vmalloc区域的某段虚拟内存区域映射到IO类型的地址。
对于ioremap：
1. 对于外设而言尽可能的使用&lt;code&gt;ioremap_nocache&lt;/code&gt;，这样子可以使得这段区域不被cache
2. 因为IO空间在不同的体系架构上有不同的解释，为了屏蔽这些区别可以使用read[b,w]、write[b,w]
3. 使用方法是&lt;code&gt;ioremap_nocache(physical start address,size)&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Per-CPU变量&lt;/h2&gt;
&lt;p&gt;per-CPU变量就是一个变量每个CPU都有一份，这样在访问这些变量的时候就不需要上锁保护以免同时被其他CPU修改，提高了效率。&lt;/p&gt;
&lt;p&gt;per-CPU被放到了特定的段内，且每个CPU都有自己的段，访问的时候就访问自己的段内的变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;__percpu&lt;/span&gt; &lt;span class="n"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;setction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;data..percpu&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xyz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;内存管理整体图&lt;/h2&gt;
&lt;p&gt;在网上看到的一个全局框图（图中的ZUNE应该为ZONE）：
&lt;img alt="Overview" src="./static/MemoryManagement/pics/MemoryManagement.gif" /&gt;&lt;/p&gt;
&lt;p&gt;图片来源于&lt;a href="http://cupic.img168.net/bbsfile/forum/linux/month_0811/20081111_9477e6fe879a69d35b15pPat2RQUajuk.gif"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;★1.CSAPP 2nd Edition：极好的书，对应的VM章节也是非常好，极其容易理解，踏实学完这本书对嵌入式开发有很大的帮助。&lt;/p&gt;
&lt;p&gt;☆2.Linux内核修炼之道：作者还有一本书比这本书有名《Linux那些事儿之我是USB》。修炼之道在大学的时候就看到了，但是看完确实在工作后的地铁上，这本书可以帮助初学linux内核的人对内核有一个总体的认识，并对linux的一些设计的进化和历史有一定的了解。同时讲述了如何查看一个驱动的代码，这些点点滴滴对于初学者是极好的辅助。推荐。&lt;/p&gt;
&lt;p&gt;★3.深入Linux设备驱动程序内核机制：博客前面的图片来源于此书。另外，这本书很不错，刚开始学习Linux设备驱动的同学可以看看，需要注意的是这本书的内核相对于现在的内核算是有点老了，但是瑕不掩瑜。同时可以结合&lt;code&gt;Linux Kernel Development&lt;/code&gt;一起学习。&lt;/p&gt;</summary><category term="ES"></category><category term="LDD"></category><category term="MemoryManagement"></category></entry><entry><title>用gitlabCI快速搭建一个GitServer与CI</title><link href="http://tonyho.github.io/%E7%94%A8gitlabCI%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAGitServer%E4%B8%8ECI.html" rel="alternate"></link><updated>2013-12-05T00:00:00+08:00</updated><author><name>TonyHo</name></author><id>tag:tonyho.github.io,2013-12-05:用gitlabCI快速搭建一个GitServer与CI.html</id><summary type="html">&lt;p&gt;一般的公司一般都有一个或者多个中央Git Server，托管着所有项目代码；同时当一个项目很大，由许多个工程组成，例如Tizen和Android，那么一般还有Continuous Integration(CI)在有人push代码到工程时编译整个项目，编译出错一般CI会发邮件给提交者和管理者，从而可以及时修正错误。&lt;/p&gt;
&lt;h2&gt;Git Server安装与使用&lt;/h2&gt;
&lt;p&gt;Git server很多，列举一部分：&lt;/p&gt;
&lt;h6&gt;Windows&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;GitStack：免费版只能有两个账号&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.fishlee.net/soft/scm-manager-chs/"&gt;SCM Manager&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h6&gt;Linux&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;GitLab&lt;/li&gt;
&lt;li&gt;Git-Deamon&lt;/li&gt;
&lt;li&gt;Git使用-bare生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;获取与安装&lt;/h3&gt;
&lt;p&gt;这里使用gitlab，到这里下载&lt;a href="http://bitnami.com/stack/gitlab"&gt;bitnami gitlab一键安装包&lt;/a&gt;。安装非常简单，只需要添加可执行权限然后用sudo ./XXX.run
执行即出现图形化的安装向导。在安装过程中需要设置用户名和密码用于后面配置使用。&lt;/p&gt;
&lt;h3&gt;gitlab的使用&lt;/h3&gt;
&lt;p&gt;直接用IP地址或者网址登陆即可。例如：&lt;code&gt;http://192.168.1.120&lt;/code&gt;，要求用户名和密码时使用安装时输入的用户名和密码。&lt;/p&gt;
&lt;p&gt;检查状态：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gitlab&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;check&lt;/span&gt; 
&lt;span class="n"&gt;Check&lt;/span&gt; &lt;span class="n"&gt;GitLab&lt;/span&gt; &lt;span class="n"&gt;API&lt;/span&gt; &lt;span class="n"&gt;access&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;OK&lt;/span&gt;
&lt;span class="n"&gt;Check&lt;/span&gt; &lt;span class="n"&gt;directories&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
    &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gitlab&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;6.3.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gitlab&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;repositories&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;OK&lt;/span&gt;
    &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;authorized_keys&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;OK&lt;/span&gt;
    &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gitlab&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;6.3.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;redis&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;redis&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cli&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上面可以看到repository的位置&lt;code&gt;/opt/gitlab-6.3.0-0/apps/gitlab/repositories&lt;/code&gt;。既然知道了repository在哪，那么我们就可以导入repo了。&lt;/p&gt;
&lt;h2&gt;Repository的导入&lt;/h2&gt;
&lt;h6&gt;什么时候需要导入Repository？&lt;/h6&gt;
&lt;p&gt;以前要想sync下Android的整个代码，需要极长的时间，现在要想repo sync下Tizen的代码，在国内一般会比较困难，经常出现&lt;code&gt;unexpected hang&lt;/code&gt;之类的错误，就算写个sync的脚本不断的去sync结果也很可能是好几天都无法sync成功。除此之外，我们很可能需要更改代码，而这个代码很可能并不愿意push到Tizen Gerrit去，这个时候，很可能就需要自己搭建一个本地的repository供开发人员使用。&lt;/p&gt;
&lt;h3&gt;如何导入一个远程仓库&lt;/h3&gt;
&lt;h6&gt;第一步：在本地生成一个bare仓库&lt;/h6&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;bare&lt;/span&gt; &lt;span class="n"&gt;PathofGitReop&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;XXXX&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考&lt;a href="http://git-scm.com/book/zh/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE"&gt;Pro Git&lt;/a&gt;&lt;/p&gt;
&lt;h6&gt;第二步：拷贝bare repository到gitlab的repositories中&lt;/h6&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="n"&gt;XXX&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gitlab&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;6.3.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gitlab&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;repositories&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h6&gt;第三步：使用&lt;/h6&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;bundle&lt;/span&gt; &lt;span class="n"&gt;exec&lt;/span&gt; &lt;span class="n"&gt;rake&lt;/span&gt; &lt;span class="n"&gt;gitlab&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;repos&lt;/span&gt; &lt;span class="n"&gt;RAILS_ENV&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;production&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考&lt;a href="https://github.com/gitlabhq/gitlabhq/wiki/Import-existing-repositories-into-GitLab"&gt;Gitlab Wiki&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外还可以在新建project中添加：
&lt;img alt="improt" src="./static/Git/pics/NewProjectImport.jpg" /&gt;&lt;/p&gt;
&lt;h3&gt;将repo切换到其他地方&lt;/h3&gt;
&lt;p&gt;让gitlab同步其他repository
参考stackoverflow上的&lt;a href="http://stackoverflow.com/questions/14288288/gitlab-repository-mirroring"&gt;这个问题回答&lt;/a&gt;&lt;/p&gt;
&lt;h6&gt;#如何导入一个本地的clone代码&lt;/h6&gt;
&lt;p&gt;有一个&lt;code&gt;.git&lt;/code&gt;的git clone目录，就是一个repository，因此可以从这个repository clone代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//IP Address/Path to the Git clone dir &lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mf"&gt;172.26.188.175&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hexiongjun&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uboot&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;imx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mf"&gt;172.26.188.175&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hexiongjun&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;如何导入一个本地的用&lt;code&gt;git clone --mirror&lt;/code&gt;产生的bare仓库&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt;    
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;IP&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;XXX&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt; 
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;otherbranch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然也可以完全不用这么麻烦，因为.git目录就是bare repository。所以也可以直接将这个copy过去。&lt;/p&gt;
&lt;p&gt;注意就现在这个版本（6.3.0），gitlab还不支持导入git协议的reop。&lt;/p&gt;
&lt;h1&gt;持续集成(Continues Integration)&lt;/h1&gt;
&lt;p&gt;持续集成(△2)，是一个在有人提交文件后对整个project不断编译构建的系统。&lt;code&gt;Jenkins&lt;/code&gt;是比较有名的持续集成系统，Gitlab也有一个CI。在安装的时候就默认会选择上。
在安装完成后可以进入到:&lt;code&gt;http://IP or Hostname/githubci&lt;/code&gt;即可进入集成系统的管理web。&lt;/p&gt;
&lt;h4&gt;添加权限&lt;/h4&gt;
&lt;p&gt;gitlab ci安装好后会创建一个叫做gitlab_ci的用户，ci要build gitlab中的项目第一不就是从gitlab中取一个项目，gitlab_ci用户需要有获取project的权限。将&lt;code&gt;/home/gitlab_ci/.ssh/id_rsa.pub&lt;/code&gt;中的内容复制粘贴到需要被ci 添加的项目中。
&lt;img alt="ssh" src="./static/Git/pics/ssh.jpg" /&gt;&lt;/p&gt;
&lt;h4&gt;编译配置&lt;/h4&gt;
&lt;p&gt;在编译脚本中如果需要配置环境变量，那么就需要注意了，如下图，因为build scripts中的每一行都是在一个单独的sh环境中运行，因此，需要将多条命令用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;整合成一条。另外在侧边可以输入branch分支。&lt;/p&gt;
&lt;p&gt;另外还有一点，在现在这个gitlabCI版本中，scripts中是不允许空行的。否则会出现&lt;code&gt;Diretory not found&lt;/code&gt;的错误提示，参考&lt;a href="https://groups.google.com/forum/#!topic/gitlabhq/RReEEyLyAGs"&gt;这里&lt;/a&gt;。
&lt;img alt="buildconfig" src="./static/Git/pics/buildscript.jpg" /&gt;点击此页面可以跳到对应的CI中。&lt;/p&gt;
&lt;p&gt;如果编译出错，那么还可以retry,先跳转到Builds页面：
&lt;img alt="buildsummary" src="./static/Git/pics/buildssummary.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;然后再右侧有一个Retry按钮：&lt;/p&gt;
&lt;p&gt;&lt;img alt="buildretry" src="./static/Git/pics/ciretry.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;对应的编译log就在此页面中。而在gitlab对应的项目网页中，页面右侧将有一个build success的图片：
&lt;img alt="sucess" src="./static/Git/pics/success.png" /&gt;&lt;/p&gt;
&lt;p&gt;这个图片的连接可以在这里找到：
&lt;img alt="sucess" src="./static/Git/buildsuccesspng.jpg" /&gt;&lt;/p&gt;
&lt;h4&gt;新添加project到CI&lt;/h4&gt;
&lt;p&gt;在新添加任务到CI中后，需要为其分配&lt;code&gt;runner&lt;/code&gt;来编译，点击下面图中Token，切换到这个runner：&lt;/p&gt;
&lt;p&gt;&lt;img alt="sucess" src="./static/Git/runnerassign.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;然后enable刚才新添加的项目。然后再对这个runner &lt;code&gt;assign to all&lt;/code&gt; 即可。
&lt;img alt="sucess" src="./static/Git/pics/runner.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;参考：&lt;/h2&gt;
&lt;p&gt;△1：&lt;a href="https://github.com/gitlabhq/gitlabhq/issues/3424"&gt;gitlab improt repo error&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;△2：&lt;a href="http://en.wikipedia.org/wiki/Continuous_integration"&gt;CI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;△3: &lt;a href="http://www.emoji-cheat-sheet.com/"&gt;可以用与gitlab的表情&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;△4: &lt;a href="http://gitolite.com/concepts/bare.html"&gt;Bare repo释义&lt;/a&gt;；另外比较简洁的理解参考&lt;a href="http://git-scm.com/book/zh/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2-Git"&gt;Pro Git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;△4: &lt;a href="https://bitnami.com/stacks"&gt;bitnami&lt;/a&gt;还提供其他许多软件的一键安装包,例如LAMP RedMine等等。&lt;/p&gt;
&lt;h2&gt;License&lt;/h2&gt;
&lt;p&gt;This blog post &lt;a href="http://creativecommons.org/licenses/by-nd/3.0/"&gt;is licensed under a Creative Commons Attribution-No Derivative Works 3.0 Norway License&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;&lt;a href="http://creativecommons.org/licenses/by-nd/3.0/"&gt;&lt;img alt="License" src="./static/Git/pics/License.png" /&gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="ES"></category></entry><entry><title>SPI Nor Flash</title><link href="http://tonyho.github.io/SPI%20Nor%20Flash.html" rel="alternate"></link><updated>2013-11-24T00:00:00+08:00</updated><author><name>TonyHo</name></author><id>tag:tonyho.github.io,2013-11-24:SPI Nor Flash.html</id><summary type="html">&lt;h2&gt;SPI协议&lt;/h2&gt;
&lt;h3&gt;Slave与Master&lt;/h3&gt;
&lt;p&gt;一般而言，提供clock的一方称为master。如下图（7-1）中的SCLK方向可知：Processor为master，而Peripheral为slave。&lt;/p&gt;
&lt;h3&gt;SPI设备接口&lt;/h3&gt;
&lt;p&gt;SPI uses four main signals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Master Out Slave In (MOSI)&lt;/li&gt;
&lt;li&gt;Master In Slave Out (MISO)&lt;/li&gt;
&lt;li&gt;Serial CLocK (SCLK or SCK) and Chip Select (CS) for the peripheral.&lt;/li&gt;
&lt;li&gt;Some processors have a dedicated chip select for SPI interfacing called Slave Select (SS).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="SPI Interface" src="./static/SPINorFlash/pics/SPI-Interface.png" /&gt;&lt;/p&gt;
&lt;h3&gt;SPI传输&lt;/h3&gt;
&lt;p&gt;SPI使用移位寄存器方式传输，示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="SPI transmission" src="./static/SPINorFlash/pics/SPITransmission.png" /&gt;&lt;/p&gt;
&lt;p&gt;形成一个&lt;code&gt;循环圈&lt;/code&gt;，任何时刻对于一个SPI设备而言都有移位输入和移位输出。&lt;/p&gt;
&lt;p&gt;如果想只读或者只写，那么在读的时候需要发送一个&lt;code&gt;dummy byte&lt;/code&gt;从而产生时钟；在写的时候简单的忽略读到的数据就可以了。&lt;/p&gt;
&lt;h3&gt;SPI传输的四种方式&lt;/h3&gt;
&lt;p&gt;根据&lt;code&gt;时钟极性&lt;/code&gt;和&lt;code&gt;时钟相位&lt;/code&gt;的不同共有四种，时钟极性和相位分别指：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时钟极性(CPOL-Clock Polarity)：空闲时的极性高（&lt;code&gt;polarity high&lt;/code&gt;）或者低（&lt;code&gt;polarity low&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;时钟相位(CPHA-CLock Phase)：在上升沿还是下降沿采样数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四种模式用图说明如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="SPI Register" src="./static/SPINorFlash/pics/spi-bus-timing.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;将四种模式的采样时刻（&lt;code&gt;Sampling edge&lt;/code&gt;）和数据变化时刻（&lt;code&gt;Toggling edge&lt;/code&gt;）截取出来：&lt;/p&gt;
&lt;p&gt;&lt;img alt="SPI Register" src="./static/SPINorFlash/pics/SPIModes.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在逻辑分析仪上面的配置有可能稍有些不一样:&lt;/p&gt;
&lt;p&gt;&lt;img alt="SPI Register" src="./static/SPINorFlash/pics/LA-SPIConfig.png" /&gt;&lt;/p&gt;
&lt;p&gt;上图是一个虚拟逻辑分析仪软件上的SPI配置截图，除了通道选择和字长度配置外，它还有其他四个设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MOSI Samples:如果是方式0和3，那么这里是上升沿，方式1和2应该配置为下降沿。看&lt;a href="./static/SPINorFlash/pics/SPIModes.jpg"&gt;前面的方式说明&lt;/a&gt;图。&lt;/li&gt;
&lt;li&gt;MISO Samples:SO和SI在同一种方式下采样边缘一般是一样的，因此同上。&lt;/li&gt;
&lt;li&gt;Use Enable:是否使用CS Pin脚。&lt;/li&gt;
&lt;li&gt;Enable Active:这个是CS有效时候的电平。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;示例：SPI寄存器配置&lt;/h2&gt;
&lt;p&gt;在某一个SoC上时钟极性和时钟相位的配置寄存器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时钟极性配置（查看前面的4种模式图可以知道模式0和模式1应该是配置为0，另外两种配置为1）：
&lt;img alt="SPI Register" src="./static/SPINorFlash/pics/SPIRegister-Polarity.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟相位配置（查看前面的&lt;a href="./static/SPINorFlash/pics/SPIModes.jpg"&gt;4种模式图&lt;/a&gt;可以知道模式1和模式3应该是配置为1【第二个edge】，另外两种配置为0）：
&lt;img alt="SPI Register" src="./static/SPINorFlash/pics/SPIRegister-Phase.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般除了方式设置外还需要对时钟速度配置，这个配置根据不同的SoC跟踪时钟如何分频过来就可以得出。并且需要注意不要超过Spi-Slave设备的最大速度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SPI reset配置：&lt;/p&gt;
&lt;h2&gt;SPI Nor Flash&lt;/h2&gt;
&lt;p&gt;这里用EN25Q128为例，简略说明一下SPI的配置。这里使用模式0标准SPI模式（只用一根DO线）。&lt;/p&gt;
&lt;h3&gt;SPI-NorFlash的接线&lt;/h3&gt;
&lt;p&gt;&lt;img alt="SPI Register" src="./static/SPINorFlash/pics/IC-Connect.png" /&gt;&lt;/p&gt;
&lt;h3&gt;EN25Q128的SPI方式&lt;/h3&gt;
&lt;p&gt;EN25Q128支持模式0和模式3。
&lt;img alt="SPI Register" src="./static/SPINorFlash/pics/SPINorMode.png" /&gt;&lt;/p&gt;
&lt;h3&gt;逻辑分析仪配置&lt;/h3&gt;
&lt;p&gt;假设使用的是SPI方式0，那么&lt;code&gt;MOSI Sampling edge&lt;/code&gt;应该设置为&lt;code&gt;Low，MISO Sampling edge&lt;/code&gt;设置为High。&lt;/p&gt;
&lt;h3&gt;SoC SPI控制寄存器配置&lt;/h3&gt;
&lt;p&gt;根据前面说过的配置好：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SoC为Master&lt;/li&gt;
&lt;li&gt;CPHA&lt;/li&gt;
&lt;li&gt;CPOL&lt;/li&gt;
&lt;li&gt;Clock Speed(使用标准模式则需要小于80MHz【◆2】)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置好后就可以使用逻辑分析仪来协助调试。&lt;/p&gt;
&lt;h3&gt;使用虚拟逻辑分析仪采集数据示意图&lt;/h3&gt;
&lt;p&gt;配置采样率和Buf size
&lt;img alt="Capture" src="./static/SPINorFlash/pics/Capture.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;【◆1】 &lt;a href="http://www.corelis.com/education/SPI_Tutorial.htm"&gt;SPI Tutorial&lt;/a&gt; 一个SPI教程。&lt;/p&gt;
&lt;p&gt;【◆2】 &lt;a href="./static/SPINorFlash/docs/EN25Q128.pdf"&gt;EN25Q128 Datasheet&lt;/a&gt; SPI NorFlash。&lt;/p&gt;
&lt;p&gt;【◆3】 &lt;a href="./static/SPINorFlash/docs/SPI_Setup_and_Hold_Times.pdf"&gt;SPI Setup and Hold Times&lt;/a&gt; 说明了为何MISO和MOSI分别在上升沿和下降沿采样。&lt;/p&gt;</summary><category term="ES"></category></entry><entry><title>Speed up Booting Embedded System</title><link href="http://tonyho.github.io/Speed%20up%20Booting%20Embedded%20System.html" rel="alternate"></link><updated>2013-10-03T00:00:00+08:00</updated><author><name>TonyHo</name></author><id>tag:tonyho.github.io,2013-10-03:Speed up Booting Embedded System.html</id><summary type="html">&lt;p&gt;嵌入式产品的启动时间一般是一个指标，像大部分Android手机几乎没有为启动加速做过优化，可以改进的地方非常多。当然因为Android用得最多的地方是手机，难得冷启动一次。&lt;/p&gt;
&lt;p&gt;用户从按下电源键开始，看到&lt;code&gt;boot logo&lt;/code&gt;/&lt;code&gt;boot splash&lt;/code&gt;到出现可操作的Home/App画面，需要的时间越少，自然越好，产品的竞争力也越强。&lt;/p&gt;
&lt;p&gt;一般没有系统的嵌入式设备启动都是上电即进入正常工作流程，这里只说linux/Android及类似的系统；下面将会简单的说明和列举从启动流程到各个启动过程都可以使用的方法，以及快速启动。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;☞启动流程&lt;/h2&gt;
&lt;p&gt;要做启动时间优化，需要对启动过程非常熟悉。下面从启动流程说起。&lt;/p&gt;
&lt;p&gt;不同的嵌入式设备启动流程很可能不一样，但是绝大部分的linux/Android设备都是一样或者类似的。
&lt;img alt="Linux-boot-sequence" src="./static/SpeedupBooting/pics/Linux-boot-sequence.png" /&gt;&lt;/p&gt;
&lt;p&gt;❤图片来源于：&lt;a href="http://processors.wiki.ti.com/index.php/Optimize_Linux_Boot_Time" title="Texas Instruments Wiki"&gt;http://processors.wiki.ti.com/index.php/Optimize_Linux_Boot_Time&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;☞工具准备：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;串口行间数据计时工具&lt;a href="http://elinux.org/Grabserial"&gt;&lt;code&gt;Grabserial&lt;/code&gt;&lt;/a&gt;的安装与使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为依赖python的serial模块，先安装它，在Ubuntu中安装python-serial：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;serial&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取工具脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wget&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//makelinux.com/emb/grabserial&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;添加可执行权限：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;chmod&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;grabserial&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置以&lt;code&gt;U-boot&lt;/code&gt;字符串出现为基准计时的使用示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;grabserial&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/dev/ttyUSB0&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="mi"&gt;115200&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;U-Boot&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果要同一行内部计时，例如解压kernel的时候是在一行内的，可以使用&lt;code&gt;-i&lt;/code&gt;选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;grabserial&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ttyUSB1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Uncompressing Linux&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;done,&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们从MMC出现时开始计时，以下为实例log，其中第一列为从出现指定字符串开始的计时，第二列为与上一行log的间隔：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;grabserial&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/dev/ttyUSB0&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="mi"&gt;115200&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;MMC:&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;Opening&lt;/span&gt; &lt;span class="n"&gt;serial&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ttyUSB0&lt;/span&gt;
&lt;span class="mi"&gt;115200&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="n"&gt;N1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xonxoff&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rtcdtc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;Program&lt;/span&gt; &lt;span class="n"&gt;will&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;
&lt;span class="n"&gt;Printing&lt;/span&gt; &lt;span class="n"&gt;timing&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;
&lt;span class="n"&gt;Matching&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Boot&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;
&lt;span class="n"&gt;Use&lt;/span&gt; &lt;span class="n"&gt;Control&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="mf"&gt;0.00&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.000&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;Board&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MX6Q&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;unknown&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;board&lt;/span&gt; &lt;span class="n"&gt;Board&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0x63012&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;POR&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="mf"&gt;2.30&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.008&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;Boot&lt;/span&gt; &lt;span class="n"&gt;Device&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SPI&lt;/span&gt; &lt;span class="n"&gt;NOR&lt;/span&gt;
&lt;span class="mf"&gt;2.30&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.012&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;I2C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;ready&lt;/span&gt;
&lt;span class="mf"&gt;2.31&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.022&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;MMC&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;FSL_USDHC&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;FSL_USDHC&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;FSL_USDHC&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;FSL_USDHC&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="mf"&gt;2.40&lt;/span&gt;       &lt;span class="mi"&gt;8&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.148&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;JEDEC&lt;/span&gt; &lt;span class="n"&gt;ID&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0xc2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0x20&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0x18&lt;/span&gt;
&lt;span class="mf"&gt;2.41&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.152&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;16384&lt;/span&gt; &lt;span class="n"&gt;KiB&lt;/span&gt; &lt;span class="n"&gt;M25P32&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="n"&gt;MB&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;now&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="n"&gt;device&lt;/span&gt;
&lt;span class="mf"&gt;2.41&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.160&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;Using&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt; &lt;span class="n"&gt;environment&lt;/span&gt;
&lt;span class="mf"&gt;2.42&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    
&lt;span class="mf"&gt;2.42&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.165&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;In&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;serial&lt;/span&gt;
&lt;span class="mf"&gt;2.42&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.168&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;serial&lt;/span&gt;
&lt;span class="mf"&gt;2.42&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.171&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;Err&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;serial&lt;/span&gt;
&lt;span class="mf"&gt;2.42&lt;/span&gt;       &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;    &lt;span class="mf"&gt;0.175&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;Net&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;尽管时间测量工具有很多当都各有各的缺点，例如这个工具就无法输入，同时在kernel、uboot分别可以设置&lt;code&gt;printk.time=1&lt;/code&gt;、 &lt;a href="http://stackoverflow.com/questions/16644430/uboot-option-to-print-boot-time-prefixes"&gt;&lt;code&gt;CONFIG_SHOW_BOOT_PROGRESS&lt;/code&gt;&lt;/a&gt;来打印时间，但是这样打印时间有几个缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;占用target的资源导致打印时间不准确&lt;/li&gt;
&lt;li&gt;如果在uboot之前还有引导程序将无法打印&lt;/li&gt;
&lt;li&gt;无法对行内计时，例如无法测量kernel解压时间&lt;code&gt;Uncompressing Linux... done&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;准备好工具，下面将按照启动流程的各个步骤来说明可以如何提高启动速度。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;☞Primary Bootloader&lt;/h2&gt;
&lt;p&gt;几乎绝大部分嵌入式SoC，在上电启动后(执行ROM Code阶段)，都会按照下面的两个方式的其中一种运行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接到某个拥有类内存接口的存储器(例如NOR-Flash)中开始执行（XIP）&lt;/li&gt;
&lt;li&gt;从Nand/SD/SPI-NorFlash等不可XIP存储设备中拷贝指定大小的内容到内部RAM中，然后在内部RAM中开始执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在许多嵌入式系统中很可能没有这个preboot（primary bootloader）的阶段（preboot我是这么叫的），或者说没有明显的primary bootloader（只编译和烧写一个bootloader文件），但是很可能在，直接就到了下面的Secondary bootloader阶段，但是不管如何&lt;/p&gt;
&lt;p&gt;尽可能只做必须要做的事情，例如只做必须的设备的初始化&lt;/p&gt;
&lt;h2&gt;☞Secondary Bootloader&lt;/h2&gt;
&lt;p&gt;这一阶段bootloader也可以认为是Secondary bootloader或者是bootloader自身的第二阶段，例如uboot中的自拷贝&lt;code&gt;relocate&lt;/code&gt;，一般按照顺序完成
初始化必须的外设，例如&lt;/p&gt;
&lt;p&gt;这一个阶段，可以考虑以下方面来提速：&lt;/p&gt;
&lt;p&gt;◕对于Cortex-A8/A9/A15使用armv7-a而不是默认的armv5来编译&lt;/p&gt;
&lt;p&gt;◕避免在primary bootloader中初始化过的设备再一次初始化&lt;/p&gt;
&lt;p&gt;◕去掉不需要的功能，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;loadb &lt;/li&gt;
&lt;li&gt;bdinfo&lt;/li&gt;
&lt;li&gt;不需要的外设初始化，例如网络设备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;◕去掉遍历搜索查询，例如如果只用到一个MMC/MTD设备，那么没有必要去遍历所有的控制器&lt;/p&gt;
&lt;p&gt;◕是否需要relocate&lt;/p&gt;
&lt;p&gt;◕用普通的存储替换hash表存储&lt;code&gt;environment&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;◕根据需要决定是否去掉uImage或者uramdisk的检验&lt;/p&gt;
&lt;p&gt;◕如果第一阶段的uramdisk很小，可以考虑直接built-in到kernel中&lt;/p&gt;
&lt;p&gt;◕如果开发精力足够，那么考虑使用其他为启动优化过的bootloader替换常规的uboot&lt;/p&gt;
&lt;h2&gt;☞kernel&lt;/h2&gt;
&lt;p&gt;uboot在启动到bootm后，会加载kernel到内存中并检验解压，然后跳入到kernel中。kernel会初始化Memory、外设等，并输出log，最后是mount rootfs，最后再跳入执行用户态的init（不同的文件系统执行的第一个程序会稍有不同，也可以在CMDLINE或者boot传入的args用&lt;code&gt;init=XXX&lt;/code&gt;指定）程序。&lt;/p&gt;
&lt;p&gt;因此上面对kernel的被加载和启动的描述，想加速就需要考虑下面几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kernel size&lt;/li&gt;
&lt;li&gt;外设等的初始化&lt;/li&gt;
&lt;li&gt;各个功能的初始化&lt;/li&gt;
&lt;li&gt;log输出&lt;/li&gt;
&lt;li&gt;文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;◕根据实际测量确定是否压缩kernel，以及选择压缩方式。&lt;/p&gt;
&lt;p&gt;◕去掉不需要的&lt;code&gt;Debug&lt;/code&gt;和&lt;code&gt;Trace&lt;/code&gt;选项，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kernel hacking里面的选择，例如Trace、KGDB&lt;/li&gt;
&lt;li&gt;Kernel debug&lt;/li&gt;
&lt;li&gt;文件系统和driver的debug&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;◕去除功能和输出冗余项，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要的外设和支持：&lt;/li&gt;
&lt;li&gt;不需要的文件系统&lt;/li&gt;
&lt;li&gt;去掉产生/proc/config.gz&lt;/li&gt;
&lt;li&gt;减少不需要的输出，去掉verbose输出。&lt;/li&gt;
&lt;li&gt;去掉能够的的Test代码编译支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;☞文件系统挂载和Userspace&lt;/h2&gt;
&lt;p&gt;在执行第一个用户程序（user space程序）时，一般会继续挂着需要的其他文件系统，加载被延后的模块，启动一些Service。例如Android的init就会根据init.&lt;code&gt;MACHINE&lt;/code&gt;.rc去执行各个任务，例如启动&lt;code&gt;bootani&lt;/code&gt;服务，启动&lt;code&gt;vold&lt;/code&gt;服务，加载驱动模块XXX.ko，启动Deamon等。其他基于busybox的很可能会去执行runlevel下的脚本和Deamon/Service。&lt;/p&gt;
&lt;p&gt;在这一阶段，我们需要做的是尽可能的让用户到达可操作状态，例如例如出现锁屏界面，或者指定应用程序。&lt;/p&gt;
&lt;p&gt;在这一阶段，因为init进程是同步的，Android的init.MACHINE.rc里面的insmod也是同步的，因此可以采取的部分方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;service和insmod的处理（可以更改init进制来从同步改成异步）&lt;/li&gt;
&lt;li&gt;尽早尽可能的并行化&lt;/li&gt;
&lt;li&gt;根据需要更改启动顺序，例如Android的bootani启动动画的可以放到后面，而不是作为第一个启动的service&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;☞Application&lt;/h2&gt;
&lt;p&gt;当kernel启动，各个必须的service/Deamon都启动后，需要的就是启动应用程序，让用户尽快的可以操作。这方面的改进可以看参考资料。&lt;/p&gt;
&lt;h2&gt;☞通用方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在编译的时候对size进行优化，去掉编译&lt;code&gt;-g&lt;/code&gt;选项。&lt;/li&gt;
&lt;li&gt;去掉log输出，在kernel可以添加&lt;code&gt;quit&lt;/code&gt;到Command line中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;☞均衡考虑&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1.Kernel驱动模块化还是built-in？ built-in不仅仅增加kernel的大小，对于kernel存储在慢设备的情况下，影响较大，且初始化会占用时间。&lt;/li&gt;
&lt;li&gt;2.存储介质的选择&lt;/li&gt;
&lt;li&gt;3.初始化的时序？这个设备/功能真的需要在一开始就初始化吗？如果不需要，那么可以在使用时在初始化吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上都是从正常启动流程来说明各个阶段可以用来提高启动速度的方法，除此外，还有一种快速启动的方法来提高启动速度--快速启动。&lt;/p&gt;
&lt;h2&gt;☞快速启动snapshot方案&lt;/h2&gt;
&lt;p&gt;许多SoC公司和solution公司都提供快速启动snapshot方案；快速启动和正常启动有着不一样的启动流程，一般省略了一些步骤。快速启动snapshot如同起名所描述的一样，在系统正常使用时，做一份snapshot保存起来，下载启动时直接恢复snapshot image。&lt;/p&gt;
&lt;p&gt;快速启动原理都是类似或者几乎一样的，应用这种方案的嵌入式系统应该算是最快的了，但是同时也是难度最大，最容易出现问题。
例如lineo提供的warp snapshot方案：&lt;/p&gt;
&lt;p&gt;1】下图表示了正常启动和用快速启动各自的启动流程，快速启动省去了一些加载流程和初始化。当然许多有自己独自寄存器的外设很可能还是需要重新初始化。&lt;/p&gt;
&lt;p&gt;&lt;img alt="warp_startup" src="./static/SpeedupBooting/pics/warp_process.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;2】下图描述了制作和解压一个snapshot image的过程。snapshot image都有压缩和解压的处理。想象一下，这里做snapshot的主存内容一定是只用到的，否则太大了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Warp_squence" src="./static/SpeedupBooting/pics/SnapshotSequence.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;❤以上两张图片来源于：&lt;a href="http://www.lineo.co.jp/modules/products/warp2.html"&gt;Lineo solution&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面的网页的引用，描述了刚才说过的快速启动制作和启动流程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Warp!! saves snapshot image of the system memory (while applications are running) and hardware status (contents of register) to the previously ensured hibernation area in secondary storage, such as Flash. Once the power is on, directly restore memory image from snapshot at a burst. By this operation, loads of initiation code loading and memory accessing are greatly reduced and achieve the high speed. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另一段描述了快速启动的特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The key of speed-up is high speed expansion of snapshot images to RAM.
- Reduce size of snapshot image to be saved.
- Ensured throughput of secondary storage.
- High speed decompression of compressed data.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如同在这个section最前面说的一样，快速启动：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;复制必要的数据到主存中&lt;/li&gt;
&lt;li&gt;然后恢复SoC的硬件状态（寄存器）
如果做出来的snapshot文件很小，且存储介质的读取速度比较快，那么将可以在冷启动后很短的时间内完成启动。否则很可能并不会加快。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;快速启动的难点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何确定哪些是被使用了的内存内容？&lt;/li&gt;
&lt;li&gt;该用什么压缩和解压算法来平衡加载时间和压缩/解压时间？&lt;/li&gt;
&lt;li&gt;很多外设和程序/Service很可能在快速启动后需要额外的处理&lt;/li&gt;
&lt;li&gt;在uboot和kernel中添加加载和制作snapshot image的驱动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题的解决，需要非常深入的Linux内存知识，以及snapshot的压缩解压算法。另外快速启动尽管也可以在linux下使用一个service来做&lt;code&gt;boot logo/splash&lt;/code&gt;，但是更常见也可能是更好的做法是在uboot中完成，而这有需要考虑snapshot image解压的时候不能覆盖&lt;code&gt;boot logo/splash&lt;/code&gt;所在的主存区域，同时在做snapshot image的时候也不要保存这部分。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;☞总结：&lt;/h2&gt;
&lt;p&gt;对正常冷启动的每个阶段都进行优化可以在一定程度上加快启动速度，甚至也可以达到很不错的效果，这些优化大都比较简单，容易实现，成本较低，花费的时间也不会太长，但在一些特殊领域，在价格等因素的考虑下，很可能无法使用快速储存器的时候，就算优化到极致也无法解决。&lt;/p&gt;
&lt;p&gt;一般而言，使用快速启动是最快的，但是难度也最大，其他的优化，很可能在用到极限也无法达到启动要求的情况下可以考虑快速启动。同时使用快速启动，会很容易出现一些service和外设的不正常，这个时候就需要对这些service和外设进行额外的处理，整个过程很可能需要耗费大量的时间，倘若较成本而言，时间更重要，也可以选择一些公司的快速启动方案。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;☞参考：&lt;/h2&gt;
&lt;p&gt;◇1 有一个非常好的加快启动速度的系列教程视频（很全面，共有三个部分，下载速度较慢）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://free-electrons.com/blog/elce-2010-tutorial-videos/"&gt;elce-2010-tutorial-videos/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;◇2 TI Wiki/u-boot上面的一个减少启动时间示例，配出了图示和一步步提高启动速度的说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://processors.wiki.ti.com/index.php/Sitara_Linux_Training:_Boot_Time_Reduction"&gt;Sitara_Linux_Training:_Boot_Time_Reduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.denx.de/wiki/DULG/AN2004_11_BootTimeOptimization"&gt;U-boot官网给出的一个减少启动时间实例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;◇3 另一个写分析和如何减少启动时间的文档,比较全面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.diva-portal.org/smash/get/diva2:235591/ATTACHMENT01"&gt;Analysis of Boot Time Reduction techniques in Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="ES"></category></entry><entry><title>ARM Linux BenchMark</title><link href="http://tonyho.github.io/ARM%20Linux%20BenchMark.html" rel="alternate"></link><updated>2013-09-21T00:00:00+08:00</updated><author><name>TonyHo</name></author><id>tag:tonyho.github.io,2013-09-21:ARM Linux BenchMark.html</id><summary type="html">&lt;h2&gt;1.背景说明&lt;/h2&gt;
&lt;p&gt;许多公司有很多不同的ARM SoC的研发产品,ARM核心可能有Cortex-A8/A9/A15，核心数可能有单核双核和四核.现在,几乎每出一款手机,网络上马上就有人对其评测.对比和评测不同ARM SoC 芯片以及嵌入式系统是非常有必要的;通过不同的SoC和其运行的OS对比,可以帮助我们了解我们产品的性能，并根据测试得知系统的瓶颈、找出需要改善的方面。&lt;/p&gt;
&lt;p&gt;嵌入式产品的硬件一般都是由处理器、主存、存储器、显示设备、以及其他外设组成。嵌入式产品的软件方面，一般都选用嵌入式系统，如小的RTOS，如VxWorks、μC/OS-III、RTT、DJYOS、FreeRTOSLinux，或者是更复杂的Linux、Android、WinCE。评测和对比的内容一般也主要由软件和硬件这两个方面组成。&lt;/p&gt;
&lt;h2&gt;2.预备基础知识&lt;/h2&gt;
&lt;p&gt;如果只是对Andorid系统或者是WinCE相关系统评测，那么我们完全可以下载一些应用（安装）运行即可评测。而如果要评测的嵌入式系统是基于Linux自己定制的甚至没有GUI的，则很可能需要我们下载源代码编译。因此对基础的编译知识的了解必不可少①。编译配置又与ARM SoC构架相关，所以需要了解一下与ARM构架以及有关的交叉编译的选项，比较ARM SoC种类较少，所以这类问题变得很简单了，一般我们需要根据需要配置&lt;code&gt;-mfpu&lt;/code&gt;和&lt;code&gt;-march&lt;/code&gt;以及&lt;code&gt;-mfloat-abi&lt;/code&gt;，以及编译优化选项。&lt;/p&gt;
&lt;h2&gt;3.评测工具介绍&lt;/h2&gt;
&lt;p&gt;评测工具有很多，在&lt;a href="http://niyunjiu.iteye.com/blog/316302"&gt;这个网页&lt;/a&gt;列出了几十个工具。单单系统性评测工具就有7个。那什么是系统性的BenchMark（引用自&lt;a href="https://code.google.com/p/byte-unixbench/"&gt;unixbench&lt;/a&gt;）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do be aware that this is a system benchmark, not a CPU, RAM or disk benchmark. The results will depend not only on your hardware, but on your operating system, libraries, and even compiler.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;系统测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用得比较广的系统性测试工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lmbench④&lt;/li&gt;
&lt;li&gt;UnixBench&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个BenchMark软件，本身是给PC上的Linux上用的，为了给嵌入式开发板子使用，需要交叉编译。和其他嵌入式程序编译一样，一般Makefile要改的只有两个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CC：指定为嵌入式交叉编译器&lt;/li&gt;
&lt;li&gt;CFLAGS：需要根据目标板ARM芯片配置②&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一些单项测试工具：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将系统测试里面的每个测试项拆开就成了单项测试，一般分为计算性能③，内存性能，图形显示。&lt;/p&gt;
&lt;p&gt;有一点需要说明的是：在linux启动过程中会打印BogoMIPS不一定准确。这方面可以参考ARM官方的说明，使用Dhrystone，当然现在在计算能力测试方面，现在大家可能更认可CoreMark和CPU2006，而不是Dhrystone。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些外设的测试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SD/eMMC可以使用dd命令来测试，例如一个读写的测试命令示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt; &lt;span class="n"&gt;sync&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mmcblk0&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4094&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;40960&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sync&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt; 
&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mmcblk0&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;zero&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4094&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;40960&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sync&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用date只能精确到秒，但是使用time命令可以精确到0.01S，所以用time更好，但是time只接受一个process作为参数。因此，需要将dd与sync整条命令放入到脚本中，再用time来运行这个脚本。&lt;/p&gt;
&lt;h2&gt;4.测试结果分析&lt;/h2&gt;
&lt;p&gt;如果就拿单单一个光秃秃的数据来看，会显得有些空白，所以一般用不同的板子数据进行对比来看。在&lt;code&gt;lmbench&lt;/code&gt;中，就可以将测试结果拷贝到result中的对应OS目录中，再用&lt;code&gt;make see&lt;/code&gt;，产生summary.out文件。其他的测试软件也有类似的功能，对于测试结果，我们需要做的是通过分析测试结果找到系统中性能与理论相差太大的不正常项目，然后去分析可能的原因并寻求解决之道。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;①可以看&lt;a href="http://forums.anandtech.com/showthread.php?t=2330027"&gt;AnTuTu and Intel&lt;/a&gt;这篇文章，里面提到了安兔兔对ICC编译器对Intel处理器的优化，ARM这边却连neon也没有使用。同时&lt;a href="http://www.eetimes.com/author.asp?section_id=36&amp;amp;doc_id=1318894"&gt;另一篇文章&lt;/a&gt;说到了安兔兔在版本变高后，评分下降的issue。&lt;/p&gt;
&lt;p&gt;②关于编译选项，可以man gcc，搜索对应的选项来查看详细内容。给出一个CLFAGS示例：
&lt;img alt="CFLAGS" src="./static/ArmBenchMark/CFLAGS.png" /&gt;
其中这些参数可以在kernel启动后使用&lt;code&gt;cat /proc/cpuinfo&lt;/code&gt;查看Arch架构。&lt;/p&gt;
&lt;p&gt;③关于计算方面的测试，有一个不错的文档&lt;a href="http://www.ee.unlv.edu/~meiyang/ecg700/readings/ARM%20Cortex-A8%20vs.%20Intel%20Atom.pdf"&gt;ARM Cortex-A8 vs. Intel Atom&lt;/a&gt;：，里面介绍了4中测试Integer和Float的工具，并用这些工具对Atom和Beagle Bone板子进行的测试比较和说明。另外&lt;a href="http://www.keil.com/benchmarks/"&gt;Keil的这个网页&lt;/a&gt;上对这些测试程序和Item也有一些介绍。&lt;/p&gt;
&lt;p&gt;④编译与运行可以参考&lt;a href="http://blog.sina.com.cn/s/blog_5d9051c00100dl2z.html"&gt;这个网页的文章&lt;/a&gt;，需要根据直接的板子SoC更改CFLAGS。&lt;/p&gt;
&lt;hr /&gt;</summary><category term="ES"></category></entry></feed>